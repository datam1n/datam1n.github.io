---
layout: default
title:
description:
permalink: "/graph"
---

<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
    #svg-container {
        width: 100%;
        height: 0px;
        overflow: auto;
        border: 2px solid #dee2e6;
        border-radius: 8px;
        position: relative;
      }
    svg {
        width: 100%;
        height: 100%;
        display: block;
    }

    .link {
        stroke: #ccc;
        stroke-opacity: 0.6;
    }

    .node circle {
        stroke: #fff;
        stroke-width: 1.5px;
    }

    text {
        font-size: 11px;
        pointer-events: none;
        font-weight: bold;
    }
    
    /* Zoom Controls */
    .zoom-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
    
    .zoom-controls button {
        width: 40px;
        height: 40px;
        border-radius: 8px;
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid #dee2e6;
        transition: all 0.2s ease;
        cursor: pointer;
        color: #2c5aa0;
        outline: none;
    }
    
    .zoom-controls button:hover {
        background: #2c5aa0;
        color: white;
        transform: scale(1.05);
    }
    
    
    /* Graph Container Enhancements */
    #svg-container {
        background: linear-gradient(45deg, #f8f9fa 25%, transparent 25%), 
                    linear-gradient(-45deg, #f8f9fa 25%, transparent 25%), 
                    linear-gradient(45deg, transparent 75%, #f8f9fa 75%), 
                    linear-gradient(-45deg, transparent 75%, #f8f9fa 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        .zoom-controls {
            top: 10px;
            right: 5px;
            flex-direction: column;
        }
        
        .zoom-controls button {
            width: 35px;
            height: 35px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    }
</style>

<!-- Graph Container with Zoom Controls -->
<div id="svg-container">
    <div class="zoom-controls">
        <button id="zoomIn" title="Zoom In">+</button>
        <button id="zoomOut" title="Zoom Out">−</button>
        <button id="resetZoom" title="Reset Zoom">⌂</button>
        <button id="exportGraph" title="Export Graph as SVG">⬇</button>
    </div>
    <svg></svg>
</div>


<script>
    const publications = {{ site.data.zotero | jsonify }};
    const members_a = {{ site.data.members.xai | jsonify }};
    const members_b = {{ site.data.members.alumni | jsonify }};
    const members_c = {{ site.data.members.others | jsonify }};
    const member_names = new Set([...members_a, ...members_b, ...members_c].map(m => m.name));

    // ==================== Build nodes and links ====================
    const nodesMap = new Map();
    const links = [];
    const years_ = new Set(publications.map(p => p.date)).size;
    const svgContainer = document.getElementById("svg-container");
    const baseHeight = 400; // for up to 10 years
    const extraHeightPerYear = 60;
    const newHeight = baseHeight + Math.max(0, years_ - 10) * extraHeightPerYear;
    svgContainer.style.height = newHeight + "px";

    for (const pub of publications) {
        const pubNode = { doi: pub.DOI, type: "paper", title: pub.title, url: pub.url, id: pub.title };
        nodesMap.set(pub.title, pubNode);

        // Year node
        if (!nodesMap.has(pub.date)) {
            nodesMap.set(pub.date, { id: pub.date, type: "year" });
        }
        links.push({ source: pub.title, target: pub.date });

        // Author nodes
        for (const author of pub.authors) {
            if (!member_names.has(author)) continue;
            if (!nodesMap.has(author)) {
                nodesMap.set(author, { id: author, type: "person" });
            }
            links.push({ source: pub.title, target: author });
        }
    }

    const nodes = Array.from(nodesMap.values());

    const connectedNodes = new Map();
    links.forEach(l => {
        if(!connectedNodes.has(l.source)) connectedNodes.set(l.source, new Set());
        if(!connectedNodes.has(l.target)) connectedNodes.set(l.target, new Set());
        connectedNodes.get(l.source).add(l.target);
        connectedNodes.get(l.target).add(l.source);
    });

    function getConnectedUpToYear(startNode, connectedNodes, nodesMap) {
        const visited = new Set();
        const result = new Set();
        const stack = [startNode.id];

        while (stack.length) {
            const currentId = stack.pop();
            if (visited.has(currentId)) continue;
                visited.add(currentId);

            const currentNode = nodesMap.get(currentId);
            if (!currentNode) continue;

            result.add(currentId);

            if ((currentNode.type === "year" && startNode.type === "person" ) ||
                (currentNode.type === "person" && currentNode.id !== startNode.id)
            ) continue;

            for (const neighborId of connectedNodes.get(currentId) || []) {
                const neighborNode = nodesMap.get(neighborId);
                if (!neighborNode) continue;

                 if (
                    neighborNode.type === "year" ||
                    (currentNode.type === "person" && neighborNode.type === "paper") ||
                    (currentNode.type === "paper" && neighborNode.type === "year") ||
                    (currentNode.type === "paper" && neighborNode.type === "person") ||
                    (currentNode.type === "year" && neighborNode.type === "paper")
                ) {
                    stack.push(neighborId);
                }
            }
        }
        return result;
    }

    nodes.forEach(node => {
        if (node.type === "person" || node.type === "year") {
            const connected = getConnectedUpToYear(node, connectedNodes, nodesMap);
            connectedNodes.set(node.id, connected);
        }
    });

    // ==================== D3 setup ====================
    const svg = d3.select("svg");
    const width = svg.node().getBoundingClientRect().width;
    const height = svg.node().getBoundingClientRect().height;
    
    // Add zoom behavior
    const zoomBehavior = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", (event) => {
            mainGroup.attr("transform", event.transform);
        });
    
    svg.call(zoomBehavior);
    
    // Create main group for all graph elements
    const mainGroup = svg.append("g");

    const color = d3.scaleOrdinal()
      .domain(["person", "paper", "year"])
      .range(["#1f77b4", "#157f71", "lightgray"]);

    /*
    const nodeSize = d3.scaleOrdinal()
      .domain(["person", "paper", "year"])
      .range([12, 12, 20]);
     */

    const personDegrees = {};
    nodes.forEach(node => {
        if (node.type === "person") {
            personDegrees[node.id] = (connectedNodes.get(node.id) || new Set()).size;
        }
    });

    const minDegree = Math.min(...Object.values(personDegrees));
    const maxDegree = Math.max(...Object.values(personDegrees));

    const personSizeScale = d3.scaleLog()
      .domain([minDegree, maxDegree])
      .range([12, 28]); // Adjust min/max size as needed

    const nodeSize = d => {
        if (d.type === "person")
            return personSizeScale(personDegrees[d.id] || minDegree);
        if (d.type == "year")
            return 20;
        if (d.type == "paper")
            return 12;
    };

    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(1))
      .force("charge", d3.forceManyBody().strength(-250))
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collision", d3.forceCollide().radius(d => nodeSize(d) + 5));


    // ==================== Draw links ====================
    const link = mainGroup.append("g")
      .attr("stroke", "#ccc")
      .attr("stroke-opacity", 0.6)
      .selectAll("line")
      .data(links)
      .join("line")
      .attr("stroke-width", 1.2);

    // ==================== Draw nodes ====================
    const node = mainGroup.append("g")
      .attr("stroke", "#fff")
      .attr("stroke-width", 1.5)
      .selectAll("circle")
      .data(nodes)
      .join("circle")
      .attr("r", d => nodeSize(d))
      .attr("fill", d => color(d.type))
      .call(selection => {
        selection.filter(d => d.type !== "year")
          .call(drag(simulation));
      })
      .on("click", (event, d) => {
        event.stopPropagation();
        if (d.type === "paper" && d.url) {
          window.open(d.url, "_blank");
        }
      })
      .on("mouseover", (event, d) => {
          const related = connectedNodes.get(d.id) || new Set();
          related.add(d.id);

          node.style("opacity", n => related.has(n.id) ? 1 : 0.1);
          link.style("opacity", l => (related.has(l.source.id) && related.has(l.target.id)) ? 1 : 0.05);
          labels.style("opacity", n => related.has(n.id) ? 1 : 0.1);
        })
        .on("mouseout", () => {
          node.style("opacity", 1);
          link.style("opacity", 0.6);
          labels.style("opacity", 1);
        })
      .append("title")
      .text(d => d.title || d.id);


        const yearNodes = nodes.filter(d => d.type === "year");
        const padding = 20;
        const timelineWidth = height - padding*4;
        const years = yearNodes.map(d => d.id).sort();
        const n = years.length;
        const verticalCount = Math.round(n * (height / (width + height)));
        const horizontalCount = n - verticalCount;

        yearNodes.forEach((d, i) => {
          d.fx = 20;
          d.fy = 2*padding + i * (timelineWidth / (years.length - 1))
        });

        /*
        yearNodes.forEach((d, i) => {
          if (i < verticalCount) {
            d.fx = padding;
            d.fy = height - padding - i * ((height - 2 * padding) / (verticalCount - 1 || 1));
          } else {
            const j = i - verticalCount + 1;
            d.fx = padding/2 + j * ((width - 2 * padding) / (horizontalCount || 1));
            d.fy = padding;
          }
        });
        */


    // ==================== Add labels ====================
    const labels = mainGroup.append("g")
      .selectAll("text")
      .data(nodes)
      .join("text")
      .text(d => d.type === "paper" ?  "📄" + d.title.split(" ").slice(0, 2).join(" ") + ' ..' : d.id)
      .attr("x", 6)
      .attr("y", 3);

    // ==================== Simulation loop ====================
    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      svg.selectAll("circle")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);

      labels
        .attr("x", d => d.x)
        .attr("y", d => d.y);
    });

    // ==================== Dragging ====================
    function drag(simulation) {
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }
      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
      return d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended);
    }

    // ==================== Interactive Features ====================
    
    // Initialize export functionality
    document.getElementById('exportGraph').addEventListener('click', exportGraph);
    
    // Zoom control functions
    document.getElementById('zoomIn').addEventListener('click', () => {
        svg.transition().duration(300).call(
            zoomBehavior.scaleBy, 1.5
        );
    });
    
    document.getElementById('zoomOut').addEventListener('click', () => {
        svg.transition().duration(300).call(
            zoomBehavior.scaleBy, 1 / 1.5
        );
    });
    
    document.getElementById('resetZoom').addEventListener('click', () => {
        svg.transition().duration(500).call(
            zoomBehavior.transform,
            d3.zoomIdentity
        );
    });

    function exportGraph() {
        // Create SVG data for export
        const svgElement = document.querySelector('#svg-container svg');
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgElement);
        const svgBlob = new Blob([svgString], {type: 'image/svg+xml;charset=utf-8'});
        const svgUrl = URL.createObjectURL(svgBlob);
        
        const downloadLink = document.createElement('a');
        downloadLink.href = svgUrl;
        downloadLink.download = 'datamin_research_graph.svg';
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
        URL.revokeObjectURL(svgUrl);
    }
</script>
